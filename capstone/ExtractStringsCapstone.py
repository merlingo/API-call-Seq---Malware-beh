from capstone import *
import struct

def extract_strings(filename, min_str_len=4):
  """
  Extracts potential strings from a binary file using Capstone and writes them to a text file.

  Args:
    filename: Path to the binary file.
    min_str_len: Minimum length for a potential string (default: 4).
  """
  # Open the binary file in read-binary mode
  with open(filename, "rb") as f:
    # Read the entire file content
    data = f.read()

  # Define architectures and modes based on your target binary
  arch = Cs(ARCH_MIPS, MODE_MIPS32)  # Replace with your target architecture and mode

  # Initialize empty list to store potential strings
  strings = []

  # Iterate through all bytes in the data
  for addr in range(0, len(data), 4):  # Adjust based on instruction size
    # Disassemble the current instruction
    insn = arch.disasm(data[addr:], 1)[0]

    # Check if the instruction is printable (might not always indicate a string)
    if insn.mnemonic not in ["db", "dq"]:  # Adjust based on common data storage instructions
      continue

    # Extract potential string based on operand data
    for operand in insn.operands:
      if operand.type == X86_OP_IMM:
        # Check for minimum string length
        if len(operand.value.bytes) >= min_str_len:
          try:
            # Attempt to decode as UTF-8 (adjust based on potential encoding)
            potential_str = operand.value.bytes.decode("utf-8")
            # Check for printable characters
            if all(ord(c) >= 32 and ord(c) <= 126 for c in potential_str):
              strings.append(f"{addr:x}: {potential_str}")
          except UnicodeDecodeError:
            pass  # Ignore decoding errors, might not be a valid string

  # Open the output file for writing
  with open("extracted_strings.txt", "w") as f:
    # Write extracted strings to the file
    f.write("\n".join(strings))

# Example usage:
filename = "your_binary.bin"  # Replace with your binary file path
extract_strings(filename)

print("Extracted strings written to extracted_strings.txt")