import networkx as nx
import matplotlib.pyplot as plt
import idc
import idaapi
import idautils
import pickle
from sys import argv
#dot->search it for visualization
def getCallGraph():
    callGraph = nx.DiGraph()
    for func_addr in idautils.Functions(MinEA(),MaxEA()): 
        #print func_addr
        #coderefler bulunur ve hepsi grapha eklenir
        fn=idc.GetFunctionName(func_addr)
        #print "for function ",fn, " caller functions listed below:"
        i=0
        callers =  idautils.CodeRefsTo(func_addr, 1)
        #avoid if there is no caller
        if(len(callers) == 0):
            #print "empty set!"
            continue
        callGraph.add_node(func_addr,name=fn)
        for caller_addr in callers:
            cn=idc.GetFunctionName(caller_addr)
            #print i,".caller is ",cn, " address: 0x %x" %caller_addr
            i+=1
            #avoid circle
            if(fn==cn):
                print fn
                continue
            cf_addr=idc.GetFunctionAttr(caller_addr, FUNCATTR_START)
            if cf_addr is None:
                #print "none function -> 0x%x"%caller_addr
                continue
            if not (cf_addr in callGraph):
                callGraph.add_node(cf_addr,name=cn)
            callGraph.add_edge(cf_addr,func_addr)
    return callGraph
def call_sequences(callGraph):
    #find root (whose degree is 1) and extract all sequences from root to bottom nodes - delete last node,
    #if deleting node which has no sibling, delete its parent node
    i=0
    callseq=[]
    roots = [n for n in callGraph if callGraph.degree(n)==1]
    cg=callGraph.copy()
    for r in roots:
        #print i,". function call below"
        callseq.append(func_rec1(cg,r))
        i=i+1
        
    writedot_digraph(callGraph,callseq,"D:\\call_graph1.txt")
    return callseq
def func_rec1(callGraph,n):
    es=list(callGraph.edges(n))
    #print len(es)
    funccal=[[n]]
    while len(es)>0:
        fc=[]
        while len(es)>0:
            e=es[0]
            if(e[1] in fc):
                #print "self looping element: ",e[1],"with edge: ",e
                callGraph.remove_edge(e[0],e[1])
                es=list(callGraph.edges(e[0]))
                continue
            #print e         
            fc.append(e[1])
            es=list(callGraph.edges(e[1]))
            #fc.extend(func_rec(callGraph,e[1]))
            #callGraph.remove_node(e[1])
        if(list(set(fc)-set(funccal[-1])) == []):
            #print "tekrar eden sequence: ",fc
            continue
        if(callGraph.has_edge(e[0],e[1])):
            callGraph.remove_edge(e[0],e[1])
        es=list(callGraph.edges(n))
        funccal.append(fc)
    return funccal
    
def writedot_digraph(cg,css,filename):
    #writing each rooted call graph into dot lang
    target = open(filename, 'w')
    target.write("digraph CFG\n")
    target.write("{\n")
    target.write("node [shape=box, style=filled, fontsize=18, color=black, fontcolor=white, width=0.3, height=0.2];")
    target.write("\nedge [color=black, fontsize=5, fontcolor=black];")
    target.write("\nentry [label=entry, fontcolor=black, color=grey];")
    target.write("\nexit [label=exit, fontcolor=black, color=grey];")
    target.write("\n entry -> ")
    for seq in css:
        r=seq[0][0]
        target.write("\n entry -> ")
        #print r
        target.write(str(r))
        target.write("\n")
        i=0
        for l in seq:
            if(i==0):
                i+=1
                continue
            dif=list(set(l)-set(seq[i-1]))
            i+=1
            #print dif
            for d in dif:
                edges=list(cg.edges(d))
                if(len(edges)>0):
                    for e in edges:
                        target.write(str(e[0]))
                        target.write("->")
                        target.write(str(e[1]))
                        target.write("\n")
   
    target.write("\n}")
    target.close()
def get_apis(func_addr):
        calls = 0
        apis = []
        #print func_addr
        flags = GetFunctionFlags(func_addr)
        # ignore library functions
        if flags & FUNC_LIB or flags & FUNC_THUNK:
            #logging.debug("get_apis: Library code or thunk")
            #print flags," ",FUNC_LIB," ", FUNC_THUNK
            return (calls, "Library code or thunk")
        # list of addresses
        start = idc.GetFunctionAttr(func_addr, FUNCATTR_START)
        end = idc.GetFunctionAttr(func_addr, FUNCATTR_END)
        cur_addr = start
        while cur_addr <= end:
            #print cur_addr
            instr = idc.GetDisasm(cur_addr)
            tmp_api_address = ""
            if idaapi.is_call_insn(cur_addr):
                # In theory an API address should only have one xrefs
                # The xrefs approach was used because I could not find how to
                # get the API name by address.
                for xref in XrefsFrom(cur_addr, idaapi.XREF_FAR):
                    if xref.to == None:
                        calls += 1
                        cur_addr = idc.NextHead(cur_addr, end)
                        continue
                    tmp_api_address = xref.to
                    break
                # get next instr since api address could not be found
                if tmp_api_address == "":
                    calls += 1
                    cur_addr = idc.NextHead(cur_addr, end)
                    continue
                api_flags = GetFunctionFlags(tmp_api_address)
                # check for lib code (api)
                if api_flags & idaapi.FUNC_LIB == True or api_flags & idaapi.FUNC_THUNK:
                    tmp_api_name = NameEx(0, tmp_api_address)
                    if tmp_api_name:
                        apis.append(tmp_api_name)
                else:
                    calls += 1
            cur_addr = idc.NextHead(cur_addr, end)
        return (calls, apis)
def get_api_call_from_sequences(seqs):
    ac=[]
    rep_cntrl=[]
    for seq in seqs:
        for ss in seq:
            for s in ss:
                if( s in rep_cntrl):
                    continue
                rep_cntrl.append(s)
                api_c=[s,get_apis(s)]
                ac.append(api_c)
    return ac
def node_have_sibling(p,root,cg):
    siblings=set()
    for s in cg.successors(p):
        if(s==n):
            continue
        siblings.add(s)
    if (len(siblings)<=0):#no sibling then predecessors's sibling will be looking for
        return node_have_sibling(cg.predecessors(n),root,cg)
    else:
        return n
def write_file(seq,filename):
    target = open(filename, 'w')
    target.write("func adress call sequences-> ")
    target.write("api call sequences")
    target.write("\n")
    api_calls=get_api_call_from_sequences(seq)
    target.write("[")
    target.write("\n")
    for api_c in api_calls:
        #print ac
        #pickle.dump(ac, target)
        #target.write(ac[0])
        #target.write(":")
        if (len(api_c[1][1])>0) & (type(api_c[1][1]) is list):
            for a in api_c[1][1]:
                target.write(str(a))
                target.write("\n")
        #target.write(ac[1])
        #target.write("\n")
    target.write("]")
    target.close()

def main():
    #mf = findMainFunc()
    mf=0x009D34B0
    callGraph = getCallGraph()
    print "finish!"
    calseq= call_sequences(callGraph)
    print calseq
    write_file(calseq,"D:\\api_call_seq.txt")
main()
#print "0x %x" % idaapi.get_func(ScreenEA()).startEA
#ea=ScreenEA()
#print "0x% x % s" % (ea, ea)
